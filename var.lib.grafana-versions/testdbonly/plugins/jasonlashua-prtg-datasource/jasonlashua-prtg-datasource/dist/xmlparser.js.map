{"version":3,"sources":["../src/xmlparser.js"],"names":["XMLXform","method","xmlString","xml","undefined","xslt","xslt2","window","DOMParser","parser","parseFromString","xsltProcessor","XSLTProcessor","importStylesheet","newxml","transformToDocument","xsltProcessor2","json","transformToFragment","document","textContent","JSON","parse"],"mappings":";;;;;;;;;;;;;;;;gCAoBaA,Q,GACX,kBAAYC,MAAZ,EAAoBC,SAApB,EAA+B;AAAA;;AAE7B,qBAAKC,GAAL,GAAWC,SAAX;AACA,qBAAKC,IAAL;;AAqCA,qBAAKC,KAAL;;AAwEA,oBAAIC,OAAOC,SAAX,EAAsB;AACpB,wBAAMC,SAAS,IAAID,SAAJ,EAAf;AACA,yBAAKL,GAAL,GAAWM,OAAOC,eAAP,CAAuBR,SAAvB,EAAkC,iBAAlC,CAAX;AACA,yBAAKG,IAAL,GAAYI,OAAOC,eAAP,CAAuB,KAAKL,IAA5B,EAAkC,iBAAlC,CAAZ;AACA,yBAAKC,KAAL,GAAaG,OAAOC,eAAP,CAAuB,KAAKJ,KAA5B,EAAmC,iBAAnC,CAAb;AACD;AACD,oBAAMK,gBAAgB,IAAIC,aAAJ,EAAtB;AACAD,8BAAcE,gBAAd,CAA+B,KAAKR,IAApC;AACA,oBAAMS,SAASH,cAAcI,mBAAd,CAAkC,KAAKZ,GAAvC,CAAf;AACA;AACA,oBAAMa,iBAAiB,IAAIJ,aAAJ,EAAvB;AACAI,+BAAeH,gBAAf,CAAgC,KAAKP,KAArC;AACA,oBAAMW,OAAOD,eAAeE,mBAAf,CAAmCJ,MAAnC,EAA2CK,QAA3C,EAAqDC,WAAlE;AACA,uBAAOC,KAAKC,KAAL,CAAWL,IAAX,CAAP;AACD,a","file":"xmlparser.js","sourcesContent":["/**\r\n * Grafana Datasource Plugin for PRTG API Interface\r\n * XML Transformation and Conversion to JSON\r\n * \r\n * 20151206 03:10 Jason Lashua\r\n * Proof of Concept. Based on publicly available plugins.\r\n *\r\n * PRTG sends data by channel, both formatted and raw, so like:\r\n * value 100%, channel 1\r\n * value_raw 100%, channel 1\r\n * value 3 gb/s, channel 2\r\n * value_raw 30492059, channel 2\r\n *\r\n * the nodes being unrelated results in repeat objects.\r\n *\r\n * first xsl sorts nodes by name, such that all <value> elements are\r\n * together, and all <value_raw> elements are together.\r\n * This results in arrays being created, which we can use.\r\n *\r\n */\r\nexport class XMLXform {\r\n  constructor(method, xmlString) {\r\n    \r\n    this.xml = undefined;\r\n    this.xslt = `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\r\n    <!--<xsl:output method=\"text\" encoding=\"utf-8\"/>-->\r\n\r\n<xsl:key name=\"kvalue\" match=\"value\" use=\"@channelid\" />\r\n<xsl:key name=\"kvalue_raw\" match=\"value_raw\" use=\"@channelid\" />\r\n\r\n\r\n <xsl:template match=\"histdata\">\r\n    <xsl:copy>\r\n        <xsl:apply-templates select=\"item\"/>\r\n    </xsl:copy>\r\n</xsl:template>\r\n\r\n<xsl:template match=\"item\">\r\n    <xsl:copy>\r\n        <xsl:apply-templates select=\"datetime\" />\r\n        <xsl:apply-templates select=\"datetime_raw\" />\r\n        <xsl:apply-templates select=\"value\">\r\n            <xsl:sort select=\"@channelid\" data-type=\"number\" order=\"ascending\" />\r\n        </xsl:apply-templates>\r\n        <xsl:apply-templates select=\"value_raw\">\r\n            <xsl:sort select=\"@channelid\" data-type=\"number\" order=\"ascending\" />\r\n        </xsl:apply-templates>\r\n    </xsl:copy>\r\n</xsl:template>\r\n<xsl:template match=\"item\">\r\n    <xsl:copy>\r\n        <xsl:copy-of select=\"datetime\" />\r\n        <xsl:copy-of select=\"datetime_raw\" />\r\n        <xsl:copy-of select=\"value\" />\r\n        <xsl:copy-of select=\"value_raw\" />\r\n    </xsl:copy>\r\n</xsl:template>\r\n</xsl:stylesheet>\r\n`;\r\n\r\n    this.xslt2 = `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\r\n    <xsl:output method=\"text\" encoding=\"utf-8\"/>\r\n \r\n    <xsl:template match=\"/*[node()]\">\r\n        <xsl:text>{</xsl:text>\r\n        <xsl:apply-templates select=\".\" mode=\"detect\" />\r\n        <xsl:text>}</xsl:text>\r\n    </xsl:template>\r\n \r\n    <xsl:template match=\"*\" mode=\"detect\">\r\n        <xsl:choose>\r\n            <xsl:when test=\"name(preceding-sibling::*[1]) = name(current()) and name(following-sibling::*[1]) != name(current())\">\r\n                    <xsl:apply-templates select=\".\" mode=\"obj-content\" />\r\n                <xsl:text>]</xsl:text>\r\n                <xsl:if test=\"count(following-sibling::*[name() != name(current())]) &gt; 0\">, </xsl:if>\r\n            </xsl:when>\r\n            <xsl:when test=\"name(preceding-sibling::*[1]) = name(current())\">\r\n                    <xsl:apply-templates select=\".\" mode=\"obj-content\" />\r\n                    <xsl:if test=\"name(following-sibling::*) = name(current())\">, </xsl:if>\r\n            </xsl:when>\r\n            <xsl:when test=\"following-sibling::*[1][name() = name(current())]\">\r\n                <xsl:text>\"</xsl:text><xsl:value-of select=\"name()\"/><xsl:text>\" : [</xsl:text>\r\n                    <xsl:apply-templates select=\".\" mode=\"obj-content\" /><xsl:text>, </xsl:text>\r\n            </xsl:when>\r\n            <xsl:when test=\"count(./child::*) > 0 or count(@*) > 0\">\r\n                <xsl:text>\"</xsl:text><xsl:value-of select=\"name()\"/>\" : <xsl:apply-templates select=\".\" mode=\"obj-content\" />\r\n                <xsl:if test=\"count(following-sibling::*) &gt; 0\">, </xsl:if>\r\n            </xsl:when>\r\n            <xsl:when test=\"count(./child::*) = 0\">\r\n                <xsl:text>\"</xsl:text><xsl:value-of select=\"name()\"/>\" : \"<xsl:apply-templates select=\".\"/><xsl:text>\"</xsl:text>\r\n                <xsl:if test=\"count(following-sibling::*) &gt; 0\">, </xsl:if>\r\n            </xsl:when>\r\n        </xsl:choose>\r\n    </xsl:template>\r\n \r\n    <xsl:template match=\"*\" mode=\"obj-content\">\r\n        <xsl:text>{</xsl:text>\r\n            <xsl:apply-templates select=\"@*\" mode=\"attr\" />\r\n            <xsl:if test=\"count(@*) &gt; 0 and (count(child::*) &gt; 0 or text())\">, </xsl:if>\r\n            <xsl:apply-templates select=\"./*\" mode=\"detect\" />\r\n            <xsl:if test=\"count(child::*) = 0 and text() and not(@*)\">\r\n                <xsl:text>\"</xsl:text><xsl:value-of select=\"name()\"/>\" : \"<xsl:value-of select=\"text()\"/><xsl:text>\"</xsl:text>\r\n            </xsl:if>\r\n            <xsl:if test=\"count(child::*) = 0 and text() and @*\">\r\n                <xsl:text>\"text\" : \"</xsl:text><xsl:value-of select=\"text()\"/><xsl:text>\"</xsl:text>\r\n            </xsl:if>\r\n        <xsl:text>}</xsl:text>\r\n        <xsl:if test=\"position() &lt; last()\">, </xsl:if>\r\n    </xsl:template>\r\n \r\n    <xsl:template match=\"@*\" mode=\"attr\">\r\n        <xsl:text>\"</xsl:text><xsl:value-of select=\"name()\"/>\" : \"<xsl:value-of select=\".\"/><xsl:text>\"</xsl:text>\r\n        <xsl:if test=\"position() &lt; last()\">,</xsl:if>\r\n    </xsl:template>\r\n \r\n    <xsl:template match=\"node/@TEXT | text()\" name=\"removeBreaks\">\r\n        <xsl:param name=\"pText\" select=\"normalize-space(.)\"/>\r\n        <xsl:choose>\r\n            <xsl:when test=\"not(contains($pText, '&#xA;'))\"><xsl:copy-of select=\"$pText\"/></xsl:when>\r\n            <xsl:otherwise>\r\n                <xsl:value-of select=\"concat(substring-before($pText, '&#xD;&#xA;'), ' ')\"/>\r\n                <xsl:call-template name=\"removeBreaks\">\r\n                    <xsl:with-param name=\"pText\" select=\"substring-after($pText, '&#xD;&#xA;')\"/>\r\n                </xsl:call-template>\r\n            </xsl:otherwise>\r\n        </xsl:choose>\r\n    </xsl:template>\r\n \r\n</xsl:stylesheet>\r\n`;\r\n\r\n    if (window.DOMParser) {\r\n      const parser = new DOMParser();  \r\n      this.xml = parser.parseFromString(xmlString, \"application/xml\");\r\n      this.xslt = parser.parseFromString(this.xslt, \"application/xml\");\r\n      this.xslt2 = parser.parseFromString(this.xslt2, \"application/xml\");\r\n    }\r\n    const xsltProcessor = new XSLTProcessor();\r\n    xsltProcessor.importStylesheet(this.xslt);\r\n    const newxml = xsltProcessor.transformToDocument(this.xml);\r\n    // Using a separate XSLTProcessor instance resolves issue with Firefox.\r\n    const xsltProcessor2 = new XSLTProcessor();\r\n    xsltProcessor2.importStylesheet(this.xslt2);\r\n    const json = xsltProcessor2.transformToFragment(newxml, document).textContent;\r\n    return JSON.parse(json);\r\n  }\r\n}\r\n\r\n"]}